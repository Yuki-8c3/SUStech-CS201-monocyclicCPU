.data 0x0000				      		
	dataset1: .space 40
	dataset2: .space 40
	dataset3: .space 40
	dataset4: .space 40

.text 0x0000
#寄存器初始化				
start:
	lui   $1,0xFFFF	           
        ori   $28,$1,0xF000	   #设置$28=0xFFFFF000
	lui    $27,0x0000
	ori   $27,$27,0x0000   #常数0,$2和$27全场景不动

	ori   $5,$27,0x0000     #数据集0地址
	ori   $6,$27,0x0028     #数据集1地址
	ori   $7,$27,0x0050     #数据集2地址
	ori   $8,$27,0x0078     #数据集3地址
	
	

main:
	#show that you are in main
	#lui $26,0xffff
        #ori $26,$26,0xffff
        #sw $26,0xC62($28)
	#lw $22,0xC72($28)

	#判断进入哪个样例
	ori $13,$27,0x0000      
	beq $22,$13,L1number
	ori $13,$27,0x0020
	beq $22,$13,L2
	ori $13,$27,0x0040
	beq $22,$13,L3
	ori $13,$27,0x0060
	beq $22,$13,L4
	ori $13,$27,0x0080
	beq $22,$13,L5
	ori $13,$27,0x00a0
	beq $22,$13,L6
	ori $13,$27,0x00c0
	beq $22,$13,L7
	ori $13,$27,0x00e0
	beq $22,$13,L8
	j main

L1number:
	ori $18,$27,0x0002   #$18低8bit=00000010 
	ori $19,$27,0x0003
	ori  $3,$27,0x0000
	lw $2,0xC70($28)    #输入测试数据的个数，存入$2,数组长度
	sw $2,0xC60($28)   
	lw $10,0xC72($28)
	beq $10,$18,L1indata        #左数第七个键为确认键
	j L1number

	L1indata:  
	#1,save in space1
	ori  $25,$27,0x0000		#$25=0
	lw $9,0xC70($28)		#$9=输入的数
	sw $9,0xC60($28)		#同步显示
	sw $9,0($5)			#存到数据集0
	sw $9,0($6)			#存到数据集1
	sw $9,0($7)			#存到数据集2
	#sw $9,0($8)
	andi $25,$3,1			#取$25的最后1bit，即判断$3为奇数还是偶数
	addi $25,$25,1                 #奇数$25=2'b10   偶数$25=2'b01
	lw $10,0xC72($28)	        
	bne $10,$25,L1indata	#奇数八上七下确认，偶数七上八下确认  
                                                #这样设计是为了消抖拨码开关

	addi $5,$5,4			#地址+4
	addi $6,$6,4
	addi $7,$7,4
	#addi $8,$8,4
	addi $3,$3,1			#计数器+1

	beq $3,$2,main
	j L1indata

L2:
	ori $18,$27,0x0001     # $18不变，一直为1
	ori $7,$27,0x0000	# $7 是循环变量i
	ori $9,$27,0x0000	# $9 是循环变量j
	ori $1,$27,0x0000
	ori $4,$27,0x0000
	ori $15,$27,0x0000
	ori $3,$27,0x0000
	ori $6,$27,0x0028	#数据集1的基地址
	ori $10,$27,0x0000
	ori $11,$27,0x0000
	ori $12,$27,0x0000
	ori $13,$27,0x0000

	loop1:
	add $9,$27,$27    # 每次执行外层循环都将内层循环的循环变量置为0 $9对应j
	loop2:
	# 获取a[j]
	addi $10,$9,0      
	sll $10,$10,2        # j*4取偏移地址
	addu $1,$10,$6    #a[j]的地址
	lw $15,0($1)  	   #15是a[j]

	# 获取a[j+1]
	addi $10,$9,1    
	sll $10,$10,2
	addu $4,$10,$6
	lw $3,0($4)          	#$3里面是a[j+1]

	sltu $11,$15,$3   	#无符号排序
	beq $11,$18,skip_2
	# 如果a[j] < a[j+1],跳转到skip代码块,不进行交换

	sw $3,0($1)   # 否则就执行下面这两句，交换两者的值
	sw $15,0($4)

	skip_2:
	addi $9,$9,1     # 内层循环变量自增，且判断是否还满足循环条件
	addi $10,$9,1   # 如果满足，则跳转到loop2
	sub $1,$2,$7    #$1=数组长度-外层循环变量i 即数组内第$1后面的数都排好序了
	slt $12,$10,$1   #如果j+1<$1，继续内层循环
	beq $12,$18,loop2
	addi $7,$7,1     # 如果不满足，则将外层循环的循环变量自增，且判断是否还满足外层循环条件
	sub $15,$2,$18  #$15=数组长度-1，为外层循环一共要循环的次数
	slt $13,$7,$15 
	beq $13,$18,loop1# 如果外层循环次数达到了，排序完成
	j main

L3:
	lui  $27,0x0000  
	ori $27,$27,0x0000     #常数0
	ori $1,$27,0x0050       #片区2基地址
	ori $20,$27,0x0078     #片区3基地址

	ori $3,$27,0x0000   #对测试数i的循环变量
	ori $7,$27,0x0000    #记着测试数最后有多少个0
	ori $8,$27,0x0001     #常数
	ori $11,$27,0x0080 #10000000
	lui $21,0x8000
	ori $21,$21,0x0000 #1, 31'b0000000
	ori $14,$27,0x0008   #常数 用来减$7
	ori $13,$27,0x0002    #常数
	ori $15,$27,0x0000    #补码结果
	ori $17,$27,0x0000    #移位时的循环变量

	loop:
	ori $7,$27,0x0000
	#lui $19,0x0000
	#ori $19,$19,0x0001
	#sw $19,0xC60($28)

	sll $18,$3,2       #偏移地址
	add $22,$20,$18    #片区3元素地址
	add $18,$1,$18    #片区2元素地址
	lw $5,0($18) 	#32bits  取出元素

	add $15,$27,$5		#copy $5到$15
	and $4,$5,$11    #判断正负数
	addi $3,$3,1       #计数器＋1
	bne $4,$11,backloop       #如果是正数，原数不动存回去

	#负数：接下来判断最后1在第几位
	add $6,$5,$27   #copy

	loopsrl:
	#lui $19,0x0000
	#ori $19,$19,0x0010
	#sw $19,0xC60($28)

	and $9,$6,$8       #$8：0x0001
	beq $9,$8,skip     
	srl $6,$6,1
	addi $7,$7,1  #记着最后有多少个0
	j loopsrl

	skip:
	#lui $19,0x0000
	#ori $19,$19,0x0100
	#sw $19,0xC60($28)

	sub $10,$14,$7       #$10=抛去最后0的位数  $14 = 8
	sub $10,$10,$13     #由于符号位和最后一个1也不用取反，所以$10-2   $10=取反Bit的位数

	ori $15,$27,0x0000  #补码结果存到15
	addi $12,$5,0           #copy

	sll $12,$12,24           #寄存器里的值是32bit，先左移24位才到我们输入的有效位数
	addi $15,$27,1          #负数符号位为0
	sll $12,$12,1             #将原数的符号位移出

	addi $17,$27,0          #$17计数器

	loopsll:   #移要反着的bits
	#lui $19,0x0000           
	#ori $19,$19,0xf000
	#sw $19,0xC60($28)

	beq $27,$10,jump    #如果反着的bit=0,跳过此环节
	and $9,$12,$21   # $21,$0,0x8000  取出最高bit
	srl $9,$9,31         #将其右移31位
	sll $15,$15,1
	sll $12,$12,1
	sub $16,$8,$9      #$16=1-$9
	add $15,$15,$16   #将反着的bit置到$15的最低位
	addi $17,$17,1      #17 counter
	bne $17,$10,loopsll  

	jump:
	ori $17,$27,0x0000    #计数器恢复0
	addi $7,$7,1              #直接落下来的bit为最后0个位数＋最后一个1

	looptail:  #移要直接放下来的bit
	#lui $19,0x0000
	#ori $19,$19,0x0001
	#sw $19,0xC62($28)

	and $9,$12,$21         #$9={1, 31'b0000000}
	srl $9,$9,31         
	sll $15,$15,1
	sll $12,$12,1
	add $15,$15,$9
	addi $17,$17,1
	bne $17,$7,looptail

	lui $19,0xffff
	ori $19,$19,0xff00
	add $15,$15,$19      #将前24bit置为1

	backloop:
	#lui $19,0x0000
	#ori $19,$19,0x0008
	#sw $19,0xC62($28)

	sw $15,0($18)         #把数存回去数据集2
	sw $15,0($22)		#把数存进数据集3
	bne $3,$2,loop        #判断是否对所有数取完补码

	ori $12,$27,0x0043    

	eComplement:
	lw $17,0xC72($28)    #因为补码只能做一次，所以需要此状态进行等待
	beq $17,$12,main     #第七八键同时打起来回main
	j eComplement


L4:
	ori $18,$27,0x0001     # $18不变，一直为1
	ori $7,$27,0x0000	# $7 是循环变量i
	ori $9,$27,0x0000	# $9 是循环变量j
	ori $1,$27,0x0000
	ori $4,$27,0x0000
	ori $15,$27,0x0000
	ori $3,$27,0x0000
	ori $6,$27,0x0078
	ori $10,$27,0x0000
	ori $11,$27,0x0000
	ori $12,$27,0x0000
	ori $13,$27,0x0000

	#整体实现和第一个排序一样，只是把stlu改成了stl
	loopp1:
	add $9,$27,$27    # 每次执行外层循环都将内层循环的循环变量置为0 $9对应j
	loopp2:
	addi $10,$9,0  # 获取a[j]
	sll $10,$10,2
	addu $1,$10,$6
	lw $15,0($1)  #15是a[j]

	addi $10,$9,1    # 获取a[j+1]
	sll $10,$10,2
	addu $4,$10,$6
	lw $3,0($4)    #$3里面是a[j+1]

	slt $11,$15,$3
	beq $11,$18,skipp
	#bltu $t2,$t3,skip  # 如果a[j] < a[j+1],跳转到skip代码块,不进行交换

	sw $3,0($1)   # 否则就执行下面这两句，交换两者的值
	sw $15,0($4)

	skipp:
	addi $9,$9,1     
	addi $10,$9,1   
	sub $1,$2,$7 
	slt $12,$10,$1
	beq $12,$18,loopp2
	
	addi $7,$7,1     
	sub $15,$2,$18
	slt $13,$7,$15
	beq $13,$18,loopp1
	j main


L5:
	lui   $27,0x0000   #常数0

	ori   $5,$27,0x0028    #数据集1地址
	ori   $20,$27,0x0001  
	ori   $19,$27,0x0080
	
	lw $6,0($5)              #第一个数
	sub $3,$2,$20		#数组长度-1=最后一个数的Index
	sll $3,$3,2                
	add $13,$5,$3          #$13=最后一个元素的地址
	lw $7,0($13)
	subu $6,$7,$6          #结果
	sw $6,0xC60($28)    #显示
	#state
	lw $10,0xC72($28)
	beq $10,$19,L5  	 #拨起左数第五个键回main
	j main

L6:
	lui   $27,0x0000   #常数0

	ori   $5,$27,0x0078
	ori   $20,$27,0x0001
	ori   $19,$27,0x00a0
	
	lw $6,0($5)
	sub $3,$2,$20
	sll $3,$3,2
	add $13,$5,$3     #$13=最后一个元素的地址
	lw $7,0($13)
	sub $6,$7,$6
	sw $6,0xC60($28)
	#state
	lw $10,0xC72($28)
	beq $10,$19,L6
	j main

L7:
	lui   $27,0x0000  
	ori $23,$27,0x00ff     #24'b0 11111111
	ori   $19,$27,0x00ca    #1100 1010回main
	ori $7,$27,0x00c1        #1100 0001
	ori $8,$27,0x00c2        #1100 0010

	input:
	lw $25,0xC70($28)         #输入数据集编号
	sw $25,0xC60($28)
	#state
	lw $10,0xC72($28)
	beq $10,$7,index            #拨上第八个键确认
	j input
	
	index:
	lw $24,0xC70($28)         #输入index
	sw $24,0xC60($28)
	#state
	lw $10,0xC72($28)
	beq $10,$8,setter		#七上八下确认
	j index

	setter:
	sll $24,$24,2			#计算偏移地址

	ori $17,$27,0x0001         #根据数据集编号判断基地址的值
	beq $17,$25,set1
	ori $17,$27,0x0002
	beq $17,$25,set2
	ori $17,$27,0x0003
	beq $17,$25,set3

	set1:
	ori $5,$27,0x0028		
	add $5,$5,$24			#计算元素地址
	j output
	
	set2:
	ori $5,$27,0x0050
	add $5,$5,$24
	j output

	set3:
	ori $5,$27,0x0078
	add $5,$5,$24
	j output

	output:
	#$5 address start
	#24 index 
	lw $21,0($5)		
	and $21,$23,$21       #取最后8bits
	sw $21,0xC60($28)    
	#state
	lw $10,0xC72($28)
	beq $10,$19,main  #1100 1001 第五个键是回main
	j output

L8:
	lui   $27,0x0000                        
	#after concern, left 8 bits
	ori $8,$27,0x00e1           #1110 0001

	ori $20,$27,0x0000
	ori $23,$27,0x0002

	ori $21,$27,0x0050         #数据集2基地址
	ori $22,$27,0x00e9		#1110 1001 第五个键是回main


	#输入Index
	input_8_1:
	#index 
	lw $5,0xC70($28)
	sw $5,0xC60($28)
	#state
	lw $6,0xC72($28)
	bne $6,$8,input_8_1     #￥8=11100000 拨起第八个键确认

	#index -> index * 4
	sll $26,$5,2

	#change 20,21
	add $20,$20,$26   #第・0个・数据集      元素地址
	add $21,$21,$26    #第・2个・数据集

        #计算数据集0的显示
	add $19,$5,$27              #存index进$19
	sll $19,$19,8			#左移8位
	lw $24,0($20)
	andi $24,$24,0x00ff		#只取低8bits
	add $19,$19,$24		#$19[15:8]:index   [7:0]:data

	#计算数据集2的显示
	add $14,$5,$27
	sll $14,$14,8
	lw $24,0($21)
	andi $24,$24,0x00ff
	add $14,$14,$24

	#set a range to count time
	lui $15,0x0200
	ori $15,$15,0x00ff               #大概为5秒左右
	
	counter:
	addi $10,$27,0
	
	show_0:
	#set a counter and then add up
	addi $10,$10,1                           

	sw $27,0xC62($28)             #显示为数据集0
	sw $19,0xC60($28)
	bne $10,$15,show_0
	
	addi $10,$27,0
	
	show_2:
	#set a counter and then add up
	addi $10,$10,1

        sw $23,0xC62($28)		#显示为数据集2
	sw $14,0xC60($28)
	bne $10,$15,show_2

	lw $6,0xC72($28)
	beq $6,$22,main	       #1110 1001 第五个键是回main
	j counter
	
	

	
	
	
	
	

	